1）题目：
在这个练习中，你将运用主成分分析（PCA）来实现降维。
首先，你将用一个二维的样本集来实验，从而对PCA如何运行的有一个直观的感受，
然后再在一个更大的由5000个人脸图像组成的数据集上实现PCA。

2）知识点概括：
--降维（dimensionality reduction）：
   压缩数据（减少内存和硬盘的需求/加速算法）
   可视化数据

--主成分分析（principal components analysis，简称PCA）
先将数据进行均值归一化（mean normalization），然后找到一个低维平面，将数据投影到上面，
使得投影误差（projection error）最小（即找到一组基向量，然后将数据投影到这个向量空间里，使得投影误差最小）

--具体步骤（将n维数据降到k维）：
  1、数据预处理（均值归一化 / 特征缩放feature scaling）
  2、计算协方差矩阵Σ ( n × n )以及它的特征向量。可以用SVD奇异值分解（Singular Value Decomposition）或eig求特征向量
  3、取U矩阵（特征向量矩阵）中前k个向量得到一个n乘k维的矩阵Ureduce，
  转置后乘以数据x就可得到降维后的数据z = X Ureduce 
​	
--k（主成分的数量）的选择
  投影误差的平方和：，PCA的目标就是最小化x和其在低维表面上的映射点之间的距离的平方。
  数据的总方差：，训练样本长度的平均值
  一般来说，就是选择k使得下式小于0.01，用PCA的语言说就是，保留了99%的差异性。
  当采取SVD分解时，上式可以等价于， Sii为S矩阵中的主对角元素（S为一个对角阵）。
  然后尝试k从1到n，选择第一个满足上式的k即可。
  也是一个平方投影误差的测量指标，即使是手动选择k时，也可以阐述百分之多少的差异性被保留了下来。

--原始数据的重构（reconstruction）
  利用z = X Ureduce得到原始数据的一个近似值

--在监督学习中可以用PCA来降低高维数据的维数，得到较低维的训练数据，再使用降维后的数据进行学习，
   使得算法更快的实现，例如在神经网络中。

--警告：
  PCA去防止过拟合是一个特别不好的应用，可能会丢失一些有价值的信息！
  此外除非在强有力的证据下说明原始数据直接建模不好（内存太大或者运行太慢），
  才使用PCA进行降维处理之后再进行建模，一般强烈建议直接用原始数据进行建模！



3）大致步骤：
1. 导入数据以及数据可视化。

2.主成分分析。首先进行数据标准化，注意这里的sigma如果取无偏的标准差，则自由度为n-1；
然后计算协方差矩阵，再进行SVD奇异值分解得到特征向量和特征值；
然后对比两个不同的特征向量（即第1列和第2列）哪个的投影误差更小，画出以数据均值为中心的特征向量，
可以看出取U矩阵中前1列得到矩阵（这里为[-0.70710678, -0.70710678]），
转置后乘以数据x就可得到降维后的数据z=XU reduce
​	
3.将数据投影到主成分上，可以得到z的第一个值为1.48127391。
然后再重建数据得到数据的近似值，因为U是特征向量矩阵，它由标准正交基组成，
因此U.T@U为单位矩阵，所以这里要重建数据只需xrec = z Ureduce ′ ，
可以得到重建后的第一行数据为[-1.04741883, -1.04741883]。
然后再可视化投影，画出标准化的数据以及投影之后又重建的数据，把对应点用虚线连接起来。
然后看看降维后的数据保留了原始数据多少的差异性，这里只有不到87%

4.导入人脸数据以及数据可视化。x是一个(5000, 1024)的数据，每列对应一个人脸图像，需要reshape成32*32的再画出。
选出前100个人脸图像进行可视化。

5.在人脸数据上实施主成分分析。先将人脸数据标准化，再计算特征向量，然后可视化前36个特征向量，
注意这里每个特征向量都是1024维的。

6.人脸数据降维以及可视化。和前面一样对数据进行降维，这里设置k=100，再进行重建数据，
画出重建后的前100个人脸图，和降维前的对比。这里93.19%的差异性保持了。

7.最后是对上次作业的一个提升，先重复上次作业中对图片进行的处理，即先运行k-means算法，
得到聚类中心和索引，然后再随机选取1000个样本像素画出三维图。之后再用PCA进行降维，画出降维后的二维图。
99.34%的差异性保持了。


4）关于Python：
plt.plot([1,2], [1,2])可以画出点[1,1]到点[2,2]的连线。
np.random.randint( )函数可以随机选择整数，没有np.的话是一个闭区间中选取，这里是一个开区间。
plt.cm.get_cmap(‘Accent’) plt.cm是matplotlib库中内置的色彩映射函数，Accent是get_cmap函数可选的一个颜色参数。
import mpl_toolkits.mplot3d as Axes3D模块可以用来绘制三维图。


.std()函数求的是标准差，np.std()的平方等于np.var()（均方差）
函数原型：numpy.var(a, axis=None, dtype=None, out=None, ddof=0, keepdims=<class numpy._globals._NoValue>)
计算张量a在axis轴上的方差

a：一个ndarray，不一定是一维
axis：可取值为None，int，int元组。当取值为None时，会把张量a展平成一维数组；当指定一个或多个int时，
         沿着axis指定的轴计算方差，其它轴的形状会保留。
dtype：在计算方差的时候使用的数据类型，如果a是int类型的张量，计算方差时也会使用float32类型
out：放置计算结果的数组，主要用于节省空间，out的维度必须保证正确
ddof：int，ddof是“Delta Degrees of Freedom”，表示自由度的个数，在计算方差时，
           分子是各个值和均值的差的平方之和，分母为（N-ddof）
keepdims：是否保留a的形状


